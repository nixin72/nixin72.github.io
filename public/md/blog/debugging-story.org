#+TITLE: Debugging a fun build failure in Clojure
#+SETUPFILE: ../templates/html.org
#+INCLUDE: header.org
#+OPTIONS: toc:1

Recently I was working on a Clojure project where I encountered a really interesting bug.

I was writing a small interpreter, and for Clojure + Java interop, I was writing some code that used
reflection to get the viable arities for any given function. This way I could throw some
compile-time errors if they were calling a function with too many arguments or something. My code
looked something like this:

#+BEGIN_SRC clojure
(defn get-static-arity [method-name all-methods]
  (into #{} (comp (filter #(and (= (.getName %) method-name)
                                (not (.isVarArgs %))))
                  (map #(-> % .getParameterTypes alength)))
        all-methods))

(defn get-variadic-arity [method-name all-methods]
  (first (into #{} (comp (filter #(and (= (.getName %) method-name)
                                       (.isVarArgs %)))
                         (map #(-> % .getParameterTypes alength)))
               all-methods)))

(defn get-fn-arity [f]
  (if (symbol? f)
    (let [[ns-name method-name] (str/split (str f) #"/")
          methods (.getDeclaredMethods (resolve (symbol ns-name)))]
      {:static (get-static-arity method-name methods)
       :variadic (get-variadic-arity method-name methods)})
    (let [methods (.getDeclaredMethods (class f))]
      {:static (get-static-arity "invoke" methods)
       :variadic (get-variadic-arity "doInvoke" methods)})))
#+END_SRC

And then this was called by passing it either a function - ~(get-fn-arity map)~ or by passing it a
symbol - ~(get-fn-arity 'Math/sqrt)~. This difference is because in Clojure we can't simply use
~Math/sqrt~ as a function - ie, we can't say ~(map Math/sqrt [1 2 3 4 5])~, because Clojure will be
looking for a field names ~sqrt~ in the ~Math~ class, not a static method. Now, there's a bug in this
code that took me a while to figure out. Both the ~get-static-arity~ and ~get-variadic-arity~ functions
worked about as expected - but the ~get-fn-arity~ never seemed to work for variadic Clojure
functions - everything else was good. I couldn't figure out what the issue was here, it worked for
Java methods, but not Clojure functions. Eventually I realized what the problem probably was -
Clojure doesn't actually implement varargs using JVM's varargs. With this suspicion, I changed that
last line to call ~get-static-arity~ and it worked great. Now, I had fixed my bug, and I had a
suspicion that I knew what caused it, but I didn't actually /know/ this for sure, so I decided to look
into the generated bytecode. At first I tried to use ~no.disassemble~, but I ran into some issues with
it, so I figured I'd just do it the "old fashioned" way and compile my project to a jar then use
~javap~ to inspect the bytecode. But when compiling my project, I encountered a new error - one that
/really/ confused me, far more than the arity bug. I got this:
#+BEGIN_SRC clojure
{:clojure.main/message
 "Syntax error (IOException) compiling fn* at (proj/validation.clj:338:3).\nFile name too long\n",
 :clojure.main/triage
 {:clojure.error/phase :compile-syntax-check,
  :clojure.error/line 338,
  :clojure.error/column 3,
  :clojure.error/source "validation.clj",
  :clojure.error/symbol fn*,
  :clojure.error/path "proj/validation.clj",
  :clojure.error/class java.io.IOException,
  :clojure.error/cause "File name too long"},
 :clojure.main/trace
 {:via [...]
  :cause "File name too long",
  :phase :compile-syntax-check}}
#+END_SRC

...File name too long? The file name is ~validation.clj~, what do you mean this is too long? That was
my first stupid thought, but of course that wasn't the issue.  Then I noticed that it was pointing
to an actual line number in my code, which of course it would, I don't know what I was initially
thinking. But, this was pointing me to a seemingly innocuous call to ~clojure.core.match/match~ -
nothing here, right? It's just some library code that I've used plenty of times before and never had
any issues...

To understand this error, we need to dig into the ~match~ macro and the Clojure compiler itself. Let's
take a look a simpler example than the ~match~ that I was working with:

#+begin_src clojure
(defn testing [x]
  (match x
    [a] a
    [a _] a
    [a _ _] a))
    #+end_src

This is a super simple use of ~match~. It simply check if the input is of length 1, 2, or 3, and
returns the first element. Not much to it. Now, we want to look at the code expanded from this to
look for lambda functions that might be generated. We're doing this because in Clojure, we're
compiling to the JVM, and what the JVM understands is classes.

Functions in Clojure actually gets compiled to a class in the JVM with methods called ~invoke~ and/or
~doInvoke~. The ~doInvoke~ methods are for variadic arities, and ~invoke~ for normal functions. Now, each
file can only contain one class, and so each function ends up getting it's own class file.

With lambda functions, this ends up looking rather messy. Lambda functions need to actually have a
name generated for their class so that it can be looked up. What Clojure ends up doing is using a
name-mangling scheme that appends a new randomly generated name to the end of the enclosing scope's
name. This means that lambda function's class names might end up looking something like

#+begin_src
namespace$my_function$fn__4240$fn__4251.class
#+end_src

And as you continue nesting lambdas, this gets longer and longer and longer... Now that we know
this, let's take a look at the expansion of the ~testing~ function above - and more importantly, the
~match~ inside it.

#+begin_src clojure
(def testing
 (fn*
   ([x]
     (try
       (if (let*
             [and__5531__auto__ (vector? x)]
             (if and__5531__auto__ (== (count x) 1) and__5531__auto__))
         (let* [a (nth x 0)] a)
         (if :else (throw clojure.core.match/backtrack) nil))
       (catch
         Exception
         e__8036__auto__
         (if (identical? e__8036__auto__ clojure.core.match/backtrack)
           (do
             (try
               (if (let*
                     [and__5531__auto__ (vector? x)]
                     (if and__5531__auto__
                       (== (count x) 2)
                       and__5531__auto__))
                 (let* [a (nth x 0)] a)
                 (if :else (throw clojure.core.match/backtrack) nil))
               (catch
                 Exception
                 e__8036__auto__
                 (if (identical?
                       e__8036__auto__
                       clojure.core.match/backtrack)
                   (do
                     (try
                       (if (let*
                             [and__5531__auto__ (vector? x)]
                             (if and__5531__auto__
                               (== (count x) 3)
                               and__5531__auto__))
                         (let* [a (nth x 0)] a)
                         (if :else
                           (throw clojure.core.match/backtrack)
                           nil))
                       (catch
                         Exception
                         e__8036__auto__
                         (if (identical?
                               e__8036__auto__
                               clojure.core.match/backtrack)
                           (do
                             (throw
                               (new
                                 java.lang.IllegalArgumentException
                                 (str "No matching clause: " x))))
                           (throw e__8036__auto__)))))
                   (throw e__8036__auto__)))))
           (throw e__8036__auto__)))))))
#+end_src

This is a rather long expansion for such a simple looking function. But, right off the bat, we can
see two different classes that will need to be generated: one for the ~testing~ var, and a second for
the function that's acutally bound to that var. But take a look at the expansion, and notice how there's
no actual other instances of ~fn*~. Now, the actual macro in question that gave me the error was much
longer, and the expanded code was well over 2000 lines long, but there was still no ~fn*~ in that code
that would be getting compiled into it's own class. So what's going on?

Clojure of course compiles to the JVM, and as such, needs to use JVM semantics for everything under
the hood. This can get tricky with things like ~if~, ~try~, loops, and other things that are statements
in the JVM. Consider the following examples:

#+begin_src clojure
(defn f []
  (if true :x :y))

(defn g []
  (if true :x :y)
  true)

(defn h []
  (let [x (if true :x :y)]
    x))
#+end_src

In ~f~, the compiler is able to see that the output value of the ~if~ is actually what's returned from
the function - this makes mapping the semantics very simple, you just return the values produced by
each branch.

In ~g~, it's even easier - there's no mapping of semantics that need to happen because you're
discarding the output value of the ~if~, making it functionall just a statement.

But in ~h~, something much more complex is going on - we're using the output value of the ~if~ and
assigning it to ~x~ - something that statement semantics can't capture.

What Clojure does in these instances is it actually wraps the ~if~ in a function taking no arguments
(a thunk), which effectively transforms the ~if~ into the case - it's now a return context. The
actual ~if~ call is then replaced with a call to the function generated. Now let's take a look at that
expansion again, and notice this ~if~:

#+begin_src clojure
(if (let*
      [and__5531__auto__ (vector? x)]
      (if and__5531__auto__
        (== (count x) 2)
        and__5531__auto__))
  (let* [a (nth x 0)] a)
  (if :else (throw clojure.core.match/backtrack) nil))
#+end_src

The condition in this ~if~ actually contains another ~if~. In Java, we can't map this to either
statement or return semantics, so we need to wrap this in a thunk and use the output of that
function as the condition to this if instead.

So now that we know this, looking at the macro we can see a few instances where this happens, and
where extra classes are going to be generated, even though the macroexpansion itself doesn't reflect
this.

So now we've finally gotten to what the issue was! ~if~ expressions in the macro expansion were
getting hoisted into thunks to map them better to statement semantics, and this caused extra
functions to be generated that wasn't visible in the actual expansion. These functions then all get
compiled into classes with successively longer names when they're nested.

This was a super interesting problem to enounter and work through and learn about. My solution in
the end was to rewrite the match as a simple ~case~ with a nested ~cond~, and this generates far fewer
lambda functions and compiles with no problem.
