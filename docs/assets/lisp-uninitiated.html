<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-02-17 Thu 15:48 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lisp for the uninitiated</title>
<meta name="author" content="Philip" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Lisp for the uninitiated</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org308c132">1. About Lisp</a></li>
<li><a href="#orgb5a59d2">2. Lisp Syntax</a></li>
<li><a href="#org12d5125">3. Prefix notation</a></li>
<li><a href="#orgce1ae87">4. Representing data</a></li>
<li><a href="#org173e9c0">5. Macros</a></li>
<li><a href="#org05df910">6. Reader macros</a></li>
<li><a href="#org1f78e6f">7. Dialects</a></li>
<li><a href="#org3f86793">8. Conclusion</a>
<ul>
<li><a href="#orgb864614">8.1. Clojure</a></li>
<li><a href="#org9b3abad">8.2. Common Lisp</a></li>
<li><a href="#org997cec7">8.3. Racket</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="org-center">
<p>
<a href="../index.html">Home</a> | <a href="../about.html">About</a> | <a href="../contact.html">Contact</a>
</p>
</div>

<div id="outline-container-org308c132" class="outline-2">
<h2 id="org308c132"><span class="section-number-2">1.</span> About Lisp</h2>
<div class="outline-text-2" id="text-1">
<blockquote>
<p>
Study C to see the power of a computer without the constraints of a language. Study Lisp to see the
power of a language without the constraints of a computer. Even if you never use either language 
professionally, they will both fundamentally change how you code for the better.
</p>
</blockquote>

<p>
This is one of my favourite quotes about Lisp, and even though it&rsquo;s from a random reddit user, I 
believe it holds true. People often talk about Lisp as though it&rsquo;s some infinitely powerful 
language and mysterious and blah blah blah. While it&rsquo;s true that Lisp is very powerful, it&rsquo;s not 
mysterious or complicated how it works.
</p>

<p>
This article is targeted towards people who maybe took a class in Lisp and really hated it, or had 
a friend show it to them but poorly explained it and were left confused, wonder why the hell you&rsquo;d 
use something so esoteric or archaic. If you&rsquo;ve never used Lisp before, but are maybe curious, 
check out my other post about [learning Lisp](lisp-for-beginners.html).
</p>

<p>
To start, I want to clarify that Lisp itself isn&rsquo;t really a programming language. Lisp is a <i>family</i>
of programming languages. Just like the &ldquo;C family&rdquo; covers C, C++, C#, Java, JS, Go, etc., the Lisp
family covers Common Lisp, Clojure, Emacs Lisp, Hy, Scheme, Racket, etc. When people say &ldquo;Lisp&rdquo;,
they&rsquo;re usually either referring to Common Lisp, but there&rsquo;s more to the world of Lisp than CL.
</p>
</div>
</div>

<div id="outline-container-orgb5a59d2" class="outline-2">
<h2 id="orgb5a59d2"><span class="section-number-2">2.</span> Lisp Syntax</h2>
<div class="outline-text-2" id="text-2">
<p>
We all know and recognize C-like languages, they&rsquo;ve got their curly braces, maybe semi-colons, if
statements, for and while loops, etc. But what does a Lisp look like if not that? Lisp uses a type
of syntax called s-expressions, and they look like this:
</p>

<div class="org-src-container">
<pre class="src src-common-lisp"><span style="color: #51afef;">(</span><span style="color: #51afef;">defun</span> <span style="color: #c678dd;">my-adder</span> <span style="color: #c678dd;">(</span>number-1 number-2<span style="color: #c678dd;">)</span>
  <span style="color: #c678dd;">(</span>print number-1<span style="color: #c678dd;">)</span>
  <span style="color: #c678dd;">(</span>print number-2<span style="color: #c678dd;">)</span>
  <span style="color: #c678dd;">(</span>print <span style="color: #98be65;">(</span>+ number-1 number-2<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
</div>

<p>
This code is pretty simple to figure out what&rsquo;s going on: it defines a function (with <code>defun</code>) named 
<code>my-adder</code> that accepts two parameters. The body of the function simply prints those two parameters, 
and then prints their sum.
</p>

<p>
There&rsquo;s nothing particularly complicated about this, but there is a lot to unpack here if you&rsquo;re
unfamiliar with the syntax. The first thing you&rsquo;ll probably notice is that there&rsquo;s a lot of
parenthesis everywhere. <code>defun</code> is inside parenthesis, the <code>print</code> function has parenthesis <i>before</i> the
function name, which is kind of weird, and even the <code>+</code> has parenthesis around it. There&rsquo;s a very good
reason for this: in Lisp, almost everything is a function. Anything that isn&rsquo;t a function, like
<code>defun</code>, uses the same syntax as function calls though. <code>+</code> is a function that adds two number. <code>print</code> is
a function that writes it&rsquo;s argument to stdout.
</p>
</div>
</div>

<div id="outline-container-org12d5125" class="outline-2">
<h2 id="org12d5125"><span class="section-number-2">3.</span> Prefix notation</h2>
<div class="outline-text-2" id="text-3">
<p>
This is pretty unfamiliar to most people, but I promose it has a very good reason for being like 
this! Think about the following code in C/C++:
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #ECBE7B;">int</span> * <span style="color: #dcaeea;">a1</span>, <span style="color: #dcaeea;">a2</span>;
</pre>
</div>

<p>
What does this code do? We know that it declared 2 variables <code>a1</code> and <code>a2</code>, that&rsquo;s not too complicated.
But we also have this <code>*</code> in here that&rsquo;s declaring them as pointers. Or is it? Is it declaring both of
them as pointers or just <code>a1</code>? To a reader, this code is <b>ambiguous</b> unless you know the order of
precedence of operations in C++. What you might <i>think</i> this code does is creates two pointers to
integers, since the <code>*</code> is a part of the type, and so it should apply to both <code>a1</code> and <code>a2</code>. However in
practice, only <code>a1</code> is a pointer and <code>a2</code> is just an integer.
</p>

<p>
In Lisp, we don&rsquo;t have this problem with operator precedence. The way that we do math in Lisp is like so:
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #51afef;">(</span>print <span style="color: #c678dd;">(</span>+ <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #98be65;">(</span>* <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #a9a1e1;">(</span>+ <span style="color: #da8548; font-weight: bold;">4</span> <span style="color: #da8548; font-weight: bold;">5</span><span style="color: #a9a1e1;">)</span><span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
</div>

<p>
And this means that we&rsquo;re first adding <code>4 + 5</code>, then multiplying <code>2 * 9</code>, then adding <code>3 + 18</code> to get <code>21</code>.
There&rsquo;s no order of orperations in Lisp, so everything is entirely unambiguous. This is one small,
but undeniable advantage to writing code using s-expressions. But this is only a small advantage
compared, the real gain comes with how we represent <b>data</b> in Lisp.
</p>
</div>
</div>

<div id="outline-container-orgce1ae87" class="outline-2">
<h2 id="orgce1ae87"><span class="section-number-2">4.</span> Representing data</h2>
<div class="outline-text-2" id="text-4">
<p>
The central data structure in Lisp is the <b>singly-linked lists</b>. If you think List and Lisp are too
close sounding, that&rsquo;s because Lisp used to be an ackronym meaning LISt Processor. The way you
create a single linked list is like this:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #51afef;">(</span><span style="color: #51afef;">defvar</span> <span style="color: #dcaeea;">my-list</span> <span style="color: #c678dd;">(</span>list <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">4</span> <span style="color: #da8548; font-weight: bold;">5</span><span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>
<span style="color: #51afef;">(</span>print my-list<span style="color: #51afef;">)</span> <span style="color: #5B6268;">; (1 2 3 4 5)</span>
</pre>
</div>

<p>
Since all of the values in that list are constant, we could equally declare that list as so:
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #51afef;">(</span><span style="color: #51afef;">defvar</span> <span style="color: #dcaeea;">my-list</span> '<span style="color: #c678dd;">(</span><span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">4</span> <span style="color: #da8548; font-weight: bold;">5</span><span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
</div>

<p>
What that quote means in Lisp is that the expression after it is not to be evaluated and everything
should be treated literaly. This means to create a nested list I could do:
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #51afef;">(</span>print '<span style="color: #c678dd;">(</span><span style="color: #98be65;">(</span><span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span><span style="color: #98be65;">)</span> <span style="color: #98be65;">(</span><span style="color: #c678dd;">:a</span> <span style="color: #c678dd;">:b</span> <span style="color: #c678dd;">:c</span><span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
</div>

<p>
And doing this is much simpler than writing out
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #51afef;">(</span>print <span style="color: #c678dd;">(</span>list <span style="color: #98be65;">(</span>list <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span><span style="color: #98be65;">)</span> <span style="color: #98be65;">(</span>list <span style="color: #c678dd;">:a</span> <span style="color: #c678dd;">:b</span> <span style="color: #c678dd;">:c</span><span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
</div>

<p>
Now, notice how the syntax for creating lists is the same as the syntax for everything else. If we do
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #51afef;">(</span>print <span style="color: #c678dd;">(</span><span style="color: #51afef;">let</span> <span style="color: #98be65;">(</span><span style="color: #a9a1e1;">(</span>x <span style="color: #da8548; font-weight: bold;">10</span><span style="color: #a9a1e1;">)</span> <span style="color: #a9a1e1;">(</span>y <span style="color: #da8548; font-weight: bold;">20</span><span style="color: #a9a1e1;">)</span><span style="color: #98be65;">)</span>
         <span style="color: #98be65;">(</span>+ x y<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
</div>

<p>
This code will declare variables <code>x</code> and <code>y</code>, calculate their sum, and then print them. But if we do
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #51afef;">(</span>print '<span style="color: #c678dd;">(</span><span style="color: #51afef;">let</span> <span style="color: #98be65;">(</span><span style="color: #a9a1e1;">(</span>x <span style="color: #da8548; font-weight: bold;">10</span><span style="color: #a9a1e1;">)</span> <span style="color: #a9a1e1;">(</span>y <span style="color: #da8548; font-weight: bold;">20</span><span style="color: #a9a1e1;">)</span><span style="color: #98be65;">)</span>
          <span style="color: #98be65;">(</span>+ x y<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
</div>

<p>
This code is now entirely different. It won&rsquo;t print the sum of the two numbers, this is now a nested
list. The first element of the list is the symbol <code>let</code> followed by another nested list, followed by
another list whose first element is <code>+</code>, then <code>x</code>, then <code>y</code>. This list would kind of be equivalent to the
following in JavaScript
</p>
<div class="org-src-container">
<pre class="src src-java">console.log<span style="color: #51afef;">(</span><span style="color: #c678dd;">[</span>Symbol<span style="color: #98be65;">(</span><span style="color: #98be65;">"let"</span><span style="color: #98be65;">)</span>, <span style="color: #98be65;">[</span><span style="color: #a9a1e1;">[</span>Symbol<span style="color: #51afef;">(</span><span style="color: #98be65;">"x"</span><span style="color: #51afef;">)</span>, <span style="color: #da8548; font-weight: bold;">10</span><span style="color: #a9a1e1;">]</span>, <span style="color: #a9a1e1;">[</span>Symbol<span style="color: #51afef;">(</span><span style="color: #98be65;">"y"</span><span style="color: #51afef;">)</span>, <span style="color: #da8548; font-weight: bold;">20</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">]</span>,
             <span style="color: #98be65;">[</span>Symbol<span style="color: #a9a1e1;">(</span><span style="color: #98be65;">"+"</span><span style="color: #a9a1e1;">)</span>, Symbol<span style="color: #a9a1e1;">(</span><span style="color: #98be65;">"x"</span><span style="color: #a9a1e1;">)</span>, Symbol<span style="color: #a9a1e1;">(</span><span style="color: #98be65;">"y"</span><span style="color: #a9a1e1;">)</span><span style="color: #98be65;">]</span><span style="color: #c678dd;">]</span><span style="color: #51afef;">)</span>
</pre>
</div>

<p>
But in Lisp, the syntax for creating lists is the exact same syntax as that for writing code. This
is a feature of a small number of programming languages that we call homoiconicity. This becomes
very important in understanding Lisp&rsquo;s <b>macros.</b>
</p>
</div>
</div>

<div id="outline-container-org173e9c0" class="outline-2">
<h2 id="org173e9c0"><span class="section-number-2">5.</span> Macros</h2>
<div class="outline-text-2" id="text-5">
<p>
In C and C++ you can define what are called macros. Macros in C/C++ are pieces of code that when
called, will replace the call to the macro with the text that it&rsquo;s declared as <b>at compile time</b>. For
example:
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #51afef; font-weight: bold;">#define</span> <span style="color: #c678dd;">print</span><span style="color: #51afef;">(</span><span style="color: #dcaeea;">a</span><span style="color: #51afef;">)</span> <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; a &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl

print<span style="color: #51afef;">(</span><span style="color: #98be65;">"hello"</span><span style="color: #51afef;">)</span>;
</pre>
</div>

<p>
What this would do is when you compile this code, a <b>textual-substituion</b> takes place. The code 
<code>print("hello")</code> would actually get replaced by the code <code>std::cout &lt;&lt; a &lt;&lt; std::endl</code>. This is a pretty
convenient feature - we can use it for writing very small &ldquo;functions&rdquo; and have them get replaced by
their definitions at compile time to eliminate the overhead of calling a function and creating a 
new stack frame.
</p>

<p>
In Lisp though, we have something even better. In Lisp, macros are actual functions that evaluate
at compile time. That sounds kinda complicated, so here&rsquo;s an example:
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #51afef;">(</span><span style="color: #51afef;">defmacro</span> <span style="color: #c678dd;">infix-&gt;prefix</span> <span style="color: #c678dd;">(</span>func-call<span style="color: #c678dd;">)</span>
  <span style="color: #c678dd;">(</span>list <span style="color: #98be65;">(</span>second func-call<span style="color: #98be65;">)</span> <span style="color: #98be65;">(</span>first func-call<span style="color: #98be65;">)</span> <span style="color: #98be65;">(</span>third func-call<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
</div>

<p>
What this does is it defines a macro called <code>infix-&gt;prefix</code>, and it takes a function &ldquo;form&rdquo; as a
parameter. The function <code>first</code> will extract the first element of a list, <code>second</code> will extract the second,
and <code>third</code> will predictably extract the 3rd. It then takes those elements and returns a new list,
with the elements in a different order so the second is now the first.
</p>

<p>
If you we&rsquo;re to call this like so:
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #51afef;">(</span>print <span style="color: #c678dd;">(</span>infix-&gt;prefix <span style="color: #98be65;">(</span><span style="color: #da8548; font-weight: bold;">1</span> + <span style="color: #da8548; font-weight: bold;">2</span><span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
</div>

<p>
Then what this does is at compile time, it&rsquo;ll transform the list <code>(1 + 2)</code> into <code>(+ 1 2)</code>, so that when 
it comes time for the program to execute, it&rsquo;ll evaluate as <code>(+ 1 2)</code> and print it at run-time.
</p>

<p>
While this example might seem somewhat trivial and not that much more powerful that C/C++ macros, 
here&rsquo;s a quote that describes the difference between the two quite well:
</p>
<blockquote>
<p>
In most programming languages, syntax is complex. Macros have to take apart program syntax, analyze 
it, and reassemble it. They do not have access to the program&rsquo;s parser, so they have to depend on 
heuristics and best-guesses. Sometimes their cut-rate analysis is wrong, and then they break.
</p>

<p>
But Lisp is different. Lisp macros do have access to the parser, and it is a really simple parser. 
A Lisp macro is not handed a string, but a pre-parsed piece of source code in the form of a list, 
because the source of a Lisp program is not a string; it is a list. And Lisp programs are really 
good at taking apart lists and putting them back together. They do this reliably, every day.&ldquo;
</p>

<ul class="org-ul">
<li>Ben Tilly</li>
</ul>
</blockquote>

<p>
Since Lisp is able to do much more complicated preprocessing like this with macros, the 
possibilities are endless. For example, you can define HTML-like syntax in Lisp for building a web 
framework pretty trivially:
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #51afef;">(</span>html
  <span style="color: #c678dd;">(</span>head <span style="color: #98be65;">(</span>title <span style="color: #98be65;">"hello world"</span><span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span>
  <span style="color: #c678dd;">(</span>body <span style="color: #98be65;">(</span><span style="color: #a9a1e1;">(</span>color <span style="color: #98be65;">"green"</span><span style="color: #a9a1e1;">)</span><span style="color: #98be65;">)</span>
    <span style="color: #98be65;">(</span>p <span style="color: #98be65;">"This is some green text"</span><span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
</div>

<p>
We can also define macros to create new control-flow structures. For example, in Lisp <code>if</code> can be a
little annoying sometimes because it looks like <code>(if &lt;cond&gt; &lt;then-expr&gt; &lt;else-expr&gt;)</code> - this means
that your cases can only contain one expression each. But what if you don&rsquo;t want an <code>else</code>, and you
want several lines in your <code>then</code> case? Well, building a macro for this is really easy.
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #51afef;">(</span><span style="color: #51afef;">defmacro</span> <span style="color: #c678dd;">when</span> <span style="color: #c678dd;">(</span>condition <span style="color: #ECBE7B;">&amp;rest</span> body<span style="color: #c678dd;">)</span>
  `<span style="color: #c678dd;">(</span><span style="color: #51afef;">if</span> ,condition <span style="color: #98be65;">(</span><span style="color: #51afef;">progn</span> ,@body<span style="color: #98be65;">)</span> nil<span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
</div>

<p>
We can then use this like so:
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #51afef;">(</span><span style="color: #51afef;">when</span> <span style="color: #c678dd;">(</span>= x y<span style="color: #c678dd;">)</span>
  <span style="color: #c678dd;">(</span>print x<span style="color: #c678dd;">)</span>
  <span style="color: #c678dd;">(</span>print y<span style="color: #c678dd;">)</span>
  <span style="color: #c678dd;">(</span>print <span style="color: #98be65;">(</span>+ x y<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
</div>

<p>
without worrying about the fact that you have multiple expressions in your body.
</p>

<p>
Macros are a very powerful abstraction tool that can allow you to represent repetitive complex
things in your code in a much more concise way. Like functions, they&rsquo;re just another building block
that Lisps give you access to so that you can build complex software as cleanly as possible.
</p>

<p>
If these regular macros don&rsquo;t sound very interesting to you, many lisp dialects such as Common Lisp
and Racket allow you to push it a step further and completly re-write the syntax of the language
using what they call <b>reader macros</b>.
</p>
</div>
</div>

<div id="outline-container-org05df910" class="outline-2">
<h2 id="org05df910"><span class="section-number-2">6.</span> Reader macros</h2>
<div class="outline-text-2" id="text-6">
<p>
While normal macros are able to transform your code into a new form, <b>reader macros</b> are able to
transform code that previously wasn&rsquo;t in valid Lisp syntax into valid syntax. This means that you
can not  only transform the code at compile time, but you can create your own syntax for an entirely
new language.
</p>

<p>
Remember earlier we talked about how that quote would make everything after it get interpreted 
literally? Well <code>quote</code> is actually the name of a macro that does that, and the <code>'</code> that we use is a 
<b>reader macro</b> that transforms it into the `quote` macro form. We can define the <code>'</code> reader macro like 
this:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #51afef;">(</span><span style="color: #51afef;">defun</span> <span style="color: #c678dd;">single-quote-reader</span> <span style="color: #c678dd;">(</span>stream char<span style="color: #c678dd;">)</span>
   <span style="color: #c678dd;">(</span><span style="color: #51afef;">declare</span> <span style="color: #98be65;">(</span>ignore char<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span>
   <span style="color: #c678dd;">(</span>list <span style="color: #98be65;">(</span>quote quote<span style="color: #98be65;">)</span> <span style="color: #98be65;">(</span>read stream t nil t<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span>

<span style="color: #51afef;">(</span>set-macro-character #\' #'single-quote-reader<span style="color: #51afef;">)</span>
</pre>
</div>

<p>
This will tell the Lisp compiler &ldquo;when you see the <code>'</code> character, take the s-expression following it, 
and give it to the function <code>single-quote-reader</code>&rdquo;. This allows us to extend the syntax of our 
language pretty simply by telling the compiler what to do when it sees a quote. Now remember how we 
had that HTML-like code, except it was still really just Lisp syntax? Well using reader macros we 
can change that and make something like this if we wanted:
</p>
<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #c678dd;">html</span>&gt;
  &lt;<span style="color: #c678dd;">head</span>&gt;
    &lt;<span style="color: #c678dd;">title</span>&gt;<span style="font-weight: bold; text-decoration: underline;">Hello world</span>&lt;/<span style="color: #c678dd;">title</span>&gt;
  &lt;/<span style="color: #c678dd;">head</span>&gt;
  &lt;<span style="color: #c678dd;">body</span> <span style="color: #dcaeea;">style</span>=<span style="color: #98be65;">"color: green"</span>&gt;
    &lt;<span style="color: #c678dd;">p</span>&gt;This is some green text&lt;/<span style="color: #c678dd;">p</span>&gt;
  &lt;/<span style="color: #c678dd;">body</span>&gt;
&lt;/<span style="color: #c678dd;">html</span>&gt;
</pre>
</div>

<p>
This can be perfectly valid Common Lisp or Racket code. It would get transformed by a complicated
set of reader macros into the s-expression version above, which would then get translated into some
more complicated generation code.
</p>

<p>
You can do some incredibly cool, and complicated stuff with reader macros such as:
</p>
<ul class="org-ul">
<li><a href="https://lisper.in/reader-macros">Allow JSON syntax in Lisp</a></li>
<li><a href="https://stackoverflow.com/questions/267862/what-makes-lisp-macros-so-special#answer-4621882">Write Python-like list comprehension</a></li>
<li><a href="https://github.com/y2q-actionman/with-c-syntax/">Embed C syntax directly into Lisp code</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1f78e6f" class="outline-2">
<h2 id="org1f78e6f"><span class="section-number-2">7.</span> Dialects</h2>
<div class="outline-text-2" id="text-7">
<p>
As mentioned at the beginning of the article, there are several dialects of Lisp. Some of the most common
ones are Clojure, Common Lisp, Scheme, Racket, and Emacs Lisp. If you&rsquo;re thinking of learning one of
them, <a href="which-lisp.html">maybe this can help you chose</a> a dialect to learn.
</p>
</div>
</div>

<div id="outline-container-org3f86793" class="outline-2">
<h2 id="org3f86793"><span class="section-number-2">8.</span> Conclusion</h2>
<div class="outline-text-2" id="text-8">
<p>
I hope you walk away from reading this understanding why Lisp is interesting. I know that it takes a
while to get used to it, and many people that learn it have a gut reaction to hate it, but
understanding the method behind the madness will make it easier to grasp.
</p>

<p>
If you&rsquo;re interested in taking some of the first steps to learning Lisp, check out some of the
resources below:
</p>
</div>

<div id="outline-container-orgb864614" class="outline-3">
<h3 id="orgb864614"><span class="section-number-3">8.1.</span> Clojure</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li><a href="https://www.braveclojure.com/clojure-for-the-brave-and-true/">Clojure for the Brave and True</a></li>
<li><a href="https://learnxinyminutes.com/docs/clojure/">Learn Clojure in Y minutes</a></li>
<li><a href="https://clojure.org/api/cheatsheet">Clojure Cheatsheet</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9b3abad" class="outline-3">
<h3 id="org9b3abad"><span class="section-number-3">8.2.</span> Common Lisp</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li><a href="https://gigamonkeys.com/book/">Practical Common Lisp (jump to Chapter 3)</a></li>
<li><a href="https://learnxinyminutes.com/docs/common-lisp/">Learn Common Lisp in Y minutes</a></li>
</ul>
</div>
</div>

<div id="outline-container-org997cec7" class="outline-3">
<h3 id="org997cec7"><span class="section-number-3">8.3.</span> Racket</h3>
<div class="outline-text-3" id="text-8-3">
<ul class="org-ul">
<li><a href="https://docs.racket-lang.org/quick/">An introduction Racket with Pictures</a></li>
<li><a href="https://docs.racket-lang.org/more/">Systems Programming with Racket </a></li>
</ul>


<p>
And if you&rsquo;re curious about the real-world applications of Lisp, or just want some more
encouragement to learn it, lisp sees more use than you might think:
</p>
<ul class="org-ul">
<li><a href="https://lisp-lang.org/">Grammarly uses Common Lisp</a> for natural language processing</li>
<li><a href="https://lisp-lang.org/">Google&rsquo;s flight search engine uses Common Lisp</a></li>
<li><a href="https://lisp-lang.org/success/">Dozens of other companies</a> use Common Lisp to much success</li>
<li><a href="https://boards.greenhouse.io/circleci">CircleCI</a> uses <a href="https://circleci.com/blog/clojure-microservices-for-js-devs-pt-1/">Clojure extensively</a> throughout it&rsquo;s <a href="https://circleci.com/blog/deploying-clojure-applications-to-google-cloud/">full stack</a></li>
<li>Clojure is used by <a href="https://clojure.org/community/companieshundreds">hundreds of other companies</a>, like Apple, Facebook, Walmart, and more</li>
<li>Clojure developers are <a href="https://insights.stackoverflow.com/survey/2018/#work-_-salary-and-experience-by-language">consistently</a> some <a href="https://insights.stackoverflow.com/survey/2019#technology-_-what-languages-are-associated-with-the-highest-salaries-worldwide">the best paid</a> in <a href="https://insights.stackoverflow.com/survey/2021#section-top-paying-technologies-top-paying-technologies">the world</a></li>
<li><a href="https://www.gameenginebook.com/resources/SINFO.pdf">Naughty Dog used Racket for PS3 and PS4 games</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Philip</p>
<p class="date">Created: 2022-02-17 Thu 15:48</p>
</div>
</body>
</html>
