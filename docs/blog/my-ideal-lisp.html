<!DOCTYPE html>

<html lang="en">
<head>
  <!-- 2022-07-18 Mon 17:57 -->
  <meta charset="utf-8">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1">

  <title>My Ideal Lisp</title>
  <meta name="author" content="Philip Dumaresq">
  <meta name="generator" content="Org Mode">
  <style type="text/css">
#content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  </style>
  <link rel="stylesheet" type="text/css" href="assets/org.css">
  <link rel="stylesheet" type="text/css" href="../assets/org.css">
  <link rel="stylesheet" type="text/css" href=
  "../../assets/org.css">
</head>

<body>
  <div id="content" class="content">
    <h1 class="title">My Ideal Lisp</h1>

    <div id="table-of-contents" role="doc-toc">
      <h2>Table of Contents</h2>

      <div id="text-table-of-contents" role="doc-toc">
        <ul>
          <li><a href="#org2ec865e">Startup time</a></li>

          <li><a href="#org52397b5">Data Structures</a></li>

          <li><a href="#org96bca0c">Error Handling</a></li>

          <li><a href="#org2b10487">Stack Traces</a></li>

          <li><a href="#orge6c7b4c">Gradual Typing</a></li>

          <li><a href="#orgf99d8c8">Summary</a></li>
        </ul>
      </div>
    </div>

    <div class="org-center">
      <p><a href="../index.html">Home</a> | <a href=
      "../about.html">About</a> | <a href=
      "../contact.html">Contact</a></p>
    </div>

    <p>I recently saw a post on r/lisp asking people if they could
    design their own lisp from scratch, what would they do? There
    was lots of interesting ideas being discussed and thrown
    around, and I started thinking about what my ideal lisp might
    look like. So here&#8217;s what I think I might like&#8230;</p>

    <p>First of all, I&#8217;d use Clojure as a base, not Common
    Lisp. I appreciate the innovation that Clojure has made to the
    lisp world in the use of other data structures, immutability,
    good concurency primitives, and other great things. However,
    there&#8217;s always room for improvement.</p>

    <div id="outline-container-org2ec865e" class="outline-2">
      <h2 id="org2ec865e">Startup time</h2>

      <div class="outline-text-2" id="text-org2ec865e">
        <p>Clojure startup time is very slow. Of course, everyone
        will tell you that this isn&#8217;t an issue most of the
        time because Clojure is designed for long-running processes
        like servers and it never hits you in development time
        cause of the REPL. Both of these are mostly true, but
        there&#8217;s still some issues here.</p>

        <p>The startup time makes Clojure entirely unusable for
        building something like a short lived command line utility.
        While this isn&#8217;t a use case that Clojure optimizes
        for, as a general-purpose programming language, it
        definitely shouldn&#8217;t be a bad choice for that, but
        I&#8217;d argue most JVM languages are. Now, there&#8217;s
        lot of ways that you can get around this. You can use a
        different runtime like ClojureScript to get nodejs like
        startup times, or babashka as an interpreted Clojure for
        even lower startup. You can also use GraalVM Native-Image
        to produce native executables from your project&#8217;s jar
        file. However, all of these alternatives have drawbacks to
        them. ClojureScript requires having node installed on a
        system and shifts you to a different ecosystem. Babashka
        requires you to have bb installed on the system and limits
        library use. GraalVM limits library use and disallows you
        from using eval.</p>

        <p>Having something with a fast startup time without these
        compromises would be very nice. Maybe something image-based
        like Common Lisp, written to target LLVM so that you have
        native performance with the compiler bundled into the
        runtime to allow things like <code>eval</code> to work.
        This way the only real compromise is on binary size, which
        is a pretty easy decision to make on most systems. Maybe
        you can also produce different kinds of executables - one
        that dynamically links to the compiler on the user&#8217;s
        system as a library, or maybe another that disallows eval
        in the code entirely? Potentially Interesting options to
        explore.</p>

        <p><b>Existing work:</b> graalvm, babashka,
        clojurescript</p>
      </div>
    </div>

    <div id="outline-container-org52397b5" class="outline-2">
      <h2 id="org52397b5">Data Structures</h2>

      <div class="outline-text-2" id="text-org52397b5">
        <p>Clojure has fantastic data structures, but there are
        some things that I find are missing from it sometimes. For
        example, I wish that Clojure had sorted maps built-in. This
        isn&#8217;t a huge deal because sorted maps and sets exist
        via libraries, but it would be nice to have syntactic
        support for them. Perhaps <code>#[]</code> could be a
        sorted map? It doesn&#8217;t make a huge amount of sense as
        an operator, but hey, Clojure doesn&#8217;t use
        <code>#[]</code> for anything. Or maybe <code>#[]</code>
        can be a syntax for queue and we can have <code>#smap
        {}</code> and <code>#sset {}</code> for sorted maps and
        sorted sets. This would probably be a little better
        actually. Either way, with queues as an important data
        structure for concurrency, it would be good to have
        first-class syntax for it, and with sorted maps and sets, I
        find myself wanting them a decent amount.</p>

        <p>Clojure&#8217;s handling of immutable data structures is
        fantastic, but when dealing with deeply nested data it can
        get tedious. Something like Spectre or lenses built-in
        could be awesome for querying and transforming deeply
        nested structures. Specter also has the advantage of not
        turning the data structure into a sequence, which is pretty
        nice. The sequence abstraction is useful, but some of the
        time it can lead to unexpected results when you forget
        you&#8217;re dealing with a <code>seq</code> and not a
        <code>vec</code>. For example, <code>conj</code> on a seq
        will add something to the beginning of the sequence, not
        the end as you&#8217;d expect with a vector.</p>

        <p><b>Existing work:</b> org.flatland/ordered, specter</p>
      </div>
    </div>

    <div id="outline-container-org96bca0c" class="outline-2">
      <h2 id="org96bca0c">Error Handling</h2>

      <div class="outline-text-2" id="text-org96bca0c">
        <p>Try/catches aren&#8217;t fantastic, but they <i>do</i>
        have significant advantages over things like maybe types or
        returning error values like Haskell or Go. Try/catches
        allow errors to be propogated up a stack much more easily,
        and don&#8217;t pollute your code with error checks, and I
        think this makes them much nicer to work with. They could
        be better though, which is why try/catches are augmented to
        also have condition/restart like behaviour to be able to do
        things like pause execution, jump to a restart handler, get
        a value to continue with, and then resume execution.
        However, I would want existing Clojure libraries to work
        too, so this would probably end up looking like&#8230;</p>

        <div class="org-src-container">
          <pre class="src src-clojure">
<span style="color: #51afef;">(</span><span style=
"color: #51afef;">defn</span> <span style=
"color: #c678dd;">some-function</span> <span style=
"color: #c678dd;">[</span>x<span style="color: #c678dd;">]</span>
  <span style="color: #c678dd;">(</span><span style=
"color: #51afef;">if</span> <span style=
"color: #98be65;">(</span>string? x<span style=
"color: #98be65;">)</span>
    <span style="color: #98be65;">(</span><span style=
"color: #51afef;">throw</span> <span style=
"color: #a9a1e1;">(</span>Exception1.<span style=
"color: #a9a1e1;">)</span><span style="color: #98be65;">)</span>
    <span style="color: #98be65;">(</span>throw-back <span style=
"color: #a9a1e1;">(</span>Execption2.<span style=
"color: #a9a1e1;">)</span><span style=
"color: #98be65;">)</span><span style=
"color: #c678dd;">)</span><span style="color: #51afef;">)</span>

<span style="color: #51afef;">(</span><span style=
"color: #51afef;">try</span>
  <span style="color: #c678dd;">(</span>some-function <span style=
"color: #da8548; font-weight: bold;">1</span><span style=
"color: #c678dd;">)</span>
  <span style="color: #c678dd;">(</span><span style=
"color: #51afef;">catch</span> Exception1 _ <span style=
"color: #da8548; font-weight: bold;">10</span><span style=
"color: #c678dd;">)</span>
  <span style=
"color: #c678dd;">(</span>handle Exception2 _ <span style=
"color: #da8548; font-weight: bold;">20</span><span style=
"color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
        </div>

        <p>Here, <code>throw</code> and <code>catch</code> work
        exactly as you would expect in Clojure. An exception gets
        thrown, you go back up the call stack until a
        <code>try</code> is encountered, you run the
        <code>catch</code> block associated with the exception type
        thrown. The <code>throw-back</code> and <code>handle</code>
        are a little different. Like <code>catch</code>, it works
        it&#8217;s way back up the call stack until a
        <code>try</code> with an associated <code>handle</code>
        block is found, but then it&#8217;s a little different.
        Then, it&#8217;ll run the <code>handle</code> block, and
        the value returned gets sent back up to
        <code>throw-back</code> call and the
        <code>throw-back</code> is substituted with the value
        returned from the <code>handle</code>. This is similar to
        the condition/restart system in Common Lisp and algebraic
        effects.</p>

        <p>It&#8217;s just a nice little extra thing to add on top
        of the normal exception handling to make it a little more
        flexible and powerful.</p>

        <p><b>Exisiting work:</b> Farolero</p>
      </div>
    </div>

    <div id="outline-container-org2b10487" class="outline-2">
      <h2 id="org2b10487">Stack Traces</h2>

      <div class="outline-text-2" id="text-org2b10487">
        <p>Clojure stack traces need to be improved. They&#8217;re
        one of the things that beginners complain about the most.
        There are existing tools in the Clojure ecosystem to
        improve stack traces, such as <a href=
        "https://ioavisopretty.readthedocs.io/en/stable/">pretty</a>,
        but these are mostly known by people who already have a
        decent amount of exposure to Clojure - so the ones who will
        already know the ecosystem.</p>

        <p><b>Existing work:</b> Pretty</p>
      </div>
    </div>

    <div id="outline-container-orge6c7b4c" class="outline-2">
      <h2 id="orge6c7b4c">Gradual Typing</h2>

      <div class="outline-text-2" id="text-orge6c7b4c">
        <p>I used to hate static typing because I thought Java is
        what static typing was. A type is a name, and anything that
        looks the same, but has a different name, is a different
        type. I thought they were restrictive, made the program
        less flexible, and were overall kind of a pain. TypeScript
        made me think otherwise. I think structural static or
        gradual typing is a joy to work with. They feel just as
        flexible as dynamically typed languages, but with the added
        safety of static typing.</p>

        <p>I would love to see a type system that&#8217;s gradually
        typed that has a separation between dynamic and statically
        typed code such that, when calling statically typed code
        from dynamic code, you get type errors thrown at runtime (a
        la spec), and static code called from static code gets full
        static typing errors. This might look something like</p>

        <div class="org-src-container">
          <pre class="src src-clojure">
<span style="color: #51afef;">(</span><span style=
"color: #51afef;">defn</span> <span style=
"color: #c678dd;">sum</span> <span style=
"color: #c678dd;">[</span><span style=
"color: #bbc2cf; background-color: #21242b;">^</span><span style=
"color: #ECBE7B;">Number</span> a <span style=
"color: #bbc2cf; background-color: #21242b;">^</span><span style=
"color: #ECBE7B;">Number</span> b<span style=
"color: #c678dd;">]</span>
  <span style="color: #c678dd;">(</span>+ a b<span style=
"color: #c678dd;">)</span><span style="color: #51afef;">)</span>

<span style="color: #51afef;">(</span>sum <span style=
"color: #da8548; font-weight: bold;">1</span> <span style=
"color: #98be65;">"2"</span><span style=
"color: #51afef;">)</span> <span style=
"color: #5B6268;">; throws runtime error here</span>

<span style="color: #51afef;">(</span><span style=
"color: #51afef;">defn</span> <span style=
"color: #c678dd;">some-fun</span> <span style=
"color: #c678dd;">[</span><span style=
"color: #bbc2cf; background-color: #21242b;">^</span><span style=
"color: #ECBE7B;">String</span> a <span style=
"color: #bbc2cf; background-color: #21242b;">^</span><span style=
"color: #ECBE7B;">String</span> b<span style=
"color: #c678dd;">]</span>
  <span style="color: #c678dd;">(</span>+ a b<span style=
"color: #c678dd;">)</span><span style=
"color: #51afef;">)</span> <span style=
"color: #5B6268;">;; </span><span style=
"color: #5B6268;">Compile time error thrown here</span>

<span style="color: #51afef;">(</span>some-fun <span style=
"color: #98be65;">"1"</span> <span style=
"color: #98be65;">"2"</span><span style=
"color: #51afef;">)</span> <span style=
"color: #5B6268;">; no run time error thrown</span>
</pre>
        </div>

        <p>I think that something like this could be very nice.
        It&#8217;s a very flexible system that provides a decent
        amount of safety, you can use this as much or as little as
        you like, and it provides some safety at the boundaries
        between static and dynamic types.</p>

        <p>I also think that when it comes to object types, a
        &#8220;minimum requirements&#8221; approach should be
        taken. Extra information provided in a map is never a bad
        thing, so why throw a type error?</p>

        <p>I think types could look nice somewhat like
        this&#8230;</p>

        <div class="org-src-container">
          <pre class="src src-clojure">
<span style="color: #51afef;">(</span>type T <span style=
"color: #c678dd;">{</span><span style=
"color: #a9a1e1;">:x</span> Integer
         <span style="color: #a9a1e1;">:y</span> Number<span style=
"color: #c678dd;">}</span><span style="color: #51afef;">)</span>

<span style="color: #51afef;">(</span>type F <span style=
"color: #c678dd;">(</span><span style=
"color: #51afef;">-&gt;</span> Number Number T<span style=
"color: #c678dd;">)</span><span style="color: #51afef;">)</span>

<span style="color: #51afef;">(</span><span style=
"color: #51afef;">defn</span> <span style=
"color: #bbc2cf; background-color: #21242b;">^</span><span style=
"color: #ECBE7B;">F</span> <span style=
"color: #c678dd;">func</span> <span style=
"color: #c678dd;">[</span>x y<span style="color: #c678dd;">]</span>
  <span style="color: #c678dd;">{</span><span style=
"color: #a9a1e1;">:x</span> x <span style=
"color: #a9a1e1;">:y</span> y<span style=
"color: #c678dd;">}</span><span style="color: #51afef;">)</span>

<span style="color: #51afef;">(</span>: map <span style=
"color: #c678dd;">(</span><span style=
"color: #51afef;">-&gt;</span> <span style=
"color: #98be65;">(</span><span style=
"color: #51afef;">-&gt;</span> 'a 'b<span style=
"color: #98be65;">)</span> &amp; <span style=
"color: #98be65;">(</span>vec 'a<span style=
"color: #98be65;">)</span> <span style=
"color: #98be65;">(</span>vec 'b<span style=
"color: #98be65;">)</span><span style=
"color: #c678dd;">)</span><span style="color: #51afef;">)</span>
<span style="color: #51afef;">(</span><span style=
"color: #51afef;">defn</span> <span style=
"color: #c678dd;">map</span> <span style=
"color: #c678dd;">[</span>f collection<span style=
"color: #c678dd;">]</span>
  <span style="color: #c678dd;">(</span><span style=
"color: #51afef;">if</span> <span style=
"color: #98be65;">(</span>empty? collection<span style=
"color: #98be65;">)</span> collection
      <span style="color: #98be65;">(</span>conj <span style=
"color: #a9a1e1;">(</span>map f collection<span style=
"color: #a9a1e1;">)</span>
            <span style="color: #a9a1e1;">(</span>f <span style=
"color: #51afef;">(</span>first collection<span style=
"color: #51afef;">)</span><span style=
"color: #a9a1e1;">)</span><span style=
"color: #98be65;">)</span><span style=
"color: #c678dd;">)</span><span style="color: #51afef;">)</span>
</pre>
        </div>

        <p>Where quoted types are perhaps treated as generics? This
        is vaguely inspired by OCaml and Typed Racket.</p>

        <p><b>Existing work:</b> TypedClojure</p>
      </div>
    </div>

    <div id="outline-container-orgf99d8c8" class="outline-2">
      <h2 id="orgf99d8c8">Summary</h2>

      <div class="outline-text-2" id="text-orgf99d8c8">
        <p>There&#8217;s a lot of things that I think Clojure could
        benefit from, but for almost everything I think is missing,
        there&#8217;s an existing solution out there. Most of these
        solutions have some drawbacks though, and could be improved
        upon. Whether it&#8217;s visibility, ease of use, or just
        that there&#8217;s compromises you aren&#8217;t really
        willing to make, there are drawbacks that aren&#8217;t
        particularly easy to solve unfortunately.</p>
      </div>
    </div>
  </div>

  <div id="postamble" class="status">
    <p class="author">Author: Philip Dumaresq</p>

    <p class="date">Created: 2022-07-18 Mon 17:57</p>
  </div>
</body>
</html>
